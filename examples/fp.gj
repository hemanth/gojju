# Gojju Examples: Functional Programming
# =======================================

print("=== Functional Programming in Gojju ===\n")

# Pipe operator for function chaining
let result = [1, 2, 3, 4, 5]
  |> map(\x -> x * 2)
  |> filter(\x -> x > 4)
  |> sum

print("Pipe result: #{result}")  # 18 (6 + 8 + 10)

# Function composition
let add_one = \x -> x + 1
let times_two = \x -> x * 2

# compose(f, g)(x) = f(g(x))
let composed = compose(times_two, add_one)
print("Composed (2 * (5 + 1)): #{composed(5)}")  # 12

# pipe is left-to-right
let piped = pipe(add_one, times_two)
print("Piped ((5 + 1) * 2): #{piped(5)}")  # 12

# Currying
let add = \a b -> a + b
let add5 = curry2(add)(5)
print("Curried add5(10): #{add5(10)}")  # 15

# Partial application
let multiply = \a b -> a * b
let double = partial(multiply, 2)
print("Partial double(7): #{double(7)}")  # 14

# Higher-order functions
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print("\nList: #{numbers}")
print("Evens: #{filter(is_even, numbers)}")
print("Odds: #{filter(is_odd, numbers)}")
print("Squared: #{map(\x -> x * x, numbers)}")

# Reduce / Fold
let sum_result = foldl(\acc x -> acc + x, 0, numbers)
print("Sum via foldl: #{sum_result}")

let product_result = foldl(\acc x -> acc * x, 1, [1, 2, 3, 4, 5])
print("Product via foldl: #{product_result}")

# Scan (running accumulator)
let running_sum = scanl(\acc x -> acc + x, 0, [1, 2, 3, 4, 5])
print("Running sum: #{running_sum}")  # [0, 1, 3, 6, 10, 15]

# List comprehensions (Python-style)
let squares = [x * x for x in range(1, 6)]
print("Squares: #{squares}")  # [1, 4, 9, 16, 25]

let even_squares = [x * x for x in range(1, 11) if x % 2 == 0]
print("Even squares: #{even_squares}")  # [4, 16, 36, 64, 100]

# Partition
let partitioned = partition(is_even, numbers)
print("Partitioned evens/odds: #{partitioned}")

# Group by
let grouped = group_by(\x -> x % 3, numbers)
print("Grouped by mod 3: #{grouped}")

# Iterate (generate sequence by applying function)
let powers_of_2 = iterate(\x -> x * 2, 1, 10)
print("Powers of 2: #{powers_of_2}")

# Unfold (build list from seed)
let countdown = unfold(\x -> nil if x < 0 else [x, x - 1], 5)
print("Countdown: #{countdown}")

# Memoization
fn slow_fib(n)
  if n <= 1
    n
  else
    slow_fib(n - 1) + slow_fib(n - 2)
  end
end

# Note: In real usage, you'd memoize during definition
print("Fibonacci 10: #{slow_fib(10)}")

# Method chaining on lists
let chained = [1, 2, 3, 4, 5]
  .map(\x -> x * 2)
  .filter(\x -> x > 4)
  .reverse()

print("Chained result: #{chained}")

print("\nâœ¨ Functional programming made easy!")
